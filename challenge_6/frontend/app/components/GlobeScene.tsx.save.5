m'use client';

import React, { useEffect, useRef, useState, useCallback, useMemo, Component, type ReactNode } from 'react';
import dynamic from 'next/dynamic';
import { CSV_TO_GEOJSON, GEOJSON_TO_CSV } from '../data/countryMapping';

// Dynamic import ‚Äî must handle .default for ES module
const Globe = dynamic(
  () => import('react-globe.gl').then((mod) => mod.default || mod),
  { ssr: false, loading: () => null }
) as any;

type GlobeMethods = any;

interface GlobeSceneProps {
  populationMap: Map<string, number>;
  onCountryClick: (geoJsonName: string) => void;
  selectedCountry: string | null;
  focusCoords: { lat: number; lng: number } | null;
  onReady: () => void;
}

/* ‚îÄ‚îÄ Error Boundary to catch Three.js / WebGL crashes ‚îÄ‚îÄ */
interface EBProps { children: ReactNode; fallback: ReactNode }
interface EBState { hasError: boolean }

class GlobeErrorBoundary extends Component<EBProps, EBState> {
  constructor(props: EBProps) { super(props); this.state = { hasError: false }; }
  static getDerivedStateFromError() { return { hasError: true }; }
  componentDidCatch(err: Error) { console.warn('[GlobeErrorBoundary]', err.message); }
  render() { return this.state.hasError ? this.props.fallback : this.props.children; }
}

// GeoJSON feature types
interface GeoFeature {
  type: string;
  properties: {
    ADMIN: string;
    ISO_A3: string;
    ISO_A2: string;
    NAME: string;
    POP_EST: number;
    [key: string]: unknown;
  };
  geometry: unknown;
  __dataIdx?: number;
}

const GEOJSON_URL = 'https://raw.githubusercontent.com/vasturiano/react-globe.gl/master/example/datasets/ne_110m_admin_0_countries.geojson';

function getPopulationColor(population: number, maxPop: number): string {
  if (!population || population === 0) return 'rgba(30, 40, 70, 0.6)';

  const logPop = Math.log10(population + 1);
  const logMax = Math.log10(maxPop + 1);
  const ratio = Math.min(logPop / logMax, 1);

  // Gradient: deep blue ‚Üí cyan ‚Üí yellow ‚Üí orange ‚Üí red
  if (ratio < 0.25) {
    const t = ratio / 0.25;
    return `rgba(${Math.round(20 + t * 0)}, ${Math.round(40 + t * 160)}, ${Math.round(80 + t * 175)}, 0.75)`;
  } else if (ratio < 0.5) {
    const t = (ratio - 0.25) / 0.25;
    return `rgba(${Math.round(20 + t * 230)}, ${Math.round(200 - t * 0)}, ${Math.round(255 - t * 155)}, 0.8)`;
  } else if (ratio < 0.75) {
    const t = (ratio - 0.5) / 0.25;
    return `rgba(${Math.round(250)}, ${Math.round(200 - t * 100)}, ${Math.round(100 - t * 60)}, 0.85)`;
  } else {
    const t = (ratio - 0.75) / 0.25;
    return `rgba(${Math.round(250 - t * 30)}, ${Math.round(100 - t * 60)}, ${Math.round(40 + t * 20)}, 0.9)`;
  }
}

function matchCountryName(geoName: string, populationMap: Map<string, number>): string | null {
  // Direct match
  if (populationMap.has(geoName)) return geoName;

  // Try reverse mapping
  const csvName = GEOJSON_TO_CSV[geoName];
  if (csvName && populationMap.has(csvName)) return csvName;

  // Case-insensitive search
  for (const [key] of populationMap) {
    if (key.toLowerCase() === geoName.toLowerCase()) return key;
    const mapped = CSV_TO_GEOJSON[key];
    if (mapped && mapped.toLowerCase() === geoName.toLowerCase()) return key;
  }

  return null;
}

export default function GlobeScene({ populationMap, onCountryClick, selectedCountry, focusCoords, onReady }: GlobeSceneProps) {
  const globeRef = useRef<GlobeMethods | undefined>(undefined);
  const [countries, setCountries] = useState<GeoFeature[]>([]);
  const [hovered, setHovered] = useState<GeoFeature | null>(null);
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const [isMounted, setIsMounted] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);

  // Client-side only mounting + WebGL check
  useEffect(() => {
    try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (gl) {
        setIsMounted(true);
      } else {
        console.warn('WebGL not available');
        setIsMounted(false);
      }
    } catch {
      setIsMounted(false);
    }
  }, []);

  // Track dimensions
  useEffect(() => {
    const updateDimensions = () => {
      if (containerRef.current) {
        setDimensions({
          width: containerRef.current.clientWidth,
          height: containerRef.current.clientHeight,
        });
      }
    };
    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);

  // Fetch GeoJSON
  useEffect(() => {
    fetch(GEOJSON_URL)
      .then(res => res.json())
      .then(data => {
        setCountries(data.features);
      });
  }, []);

  // Configure globe on mount
  useEffect(() => {
    if (!globeRef.current) return;
    const globe = globeRef.current;

    // Set initial point of view
    globe.pointOfView({ lat: 20, lng: 30, altitude: 2.2 }, 0);

    // Configure controls
    const controls = globe.controls();
    if (controls) {
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.4;
      controls.enableZoom = true;
      controls.minDistance = 150;
      controls.maxDistance = 600;
    }

    // Signal ready after a short delay
    setTimeout(() => onReady(), 1500);
  }, [countries, onReady]);

  // Focus on country when selected
  useEffect(() => {
    if (!focusCoords || !globeRef.current) return;
    const globe = globeRef.current;

    // Stop auto-rotation temporarily
    const controls = globe.controls();
    if (controls) {
      controls.autoRotate = false;
    }

    globe.pointOfView({
      lat: focusCoords.lat,
      lng: focusCoords.lng,
      altitude: 1.8,
    }, 1000);

    // Resume auto-rotation after zoom
    const timeout = setTimeout(() => {
      if (controls) {
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.15;
      }
    }, 5000);

    return () => clearTimeout(timeout);
  }, [focusCoords]);

  const maxPop = useMemo(() => {
    let max = 0;
    for (const [, pop] of populationMap) {
      if (pop > max) max = pop;
    }
    return max;
  }, [populationMap]);

  // Map selected country to GeoJSON name for comparison
  const selectedGeoName = useMemo(() => {
    if (!selectedCountry) return null;
    return CSV_TO_GEOJSON[selectedCountry] || selectedCountry;
  }, [selectedCountry]);

  const getPolygonCapColor = useCallback((d: object) => {
    const feat = d as GeoFeature;
    const name = feat.properties.ADMIN || feat.properties.NAME;
    const isSelected = name === selectedGeoName || name === selectedCountry;
    const isHovered = hovered && (hovered.properties.ADMIN === name || hovered.properties.NAME === name);

    if (isSelected) return 'rgba(0, 212, 255, 0.6)';
    if (isHovered) return 'rgba(0, 212, 255, 0.35)';

    const csvName = matchCountryName(name, populationMap);
    const pop = csvName ? populationMap.get(csvName) || 0 : 0;
    return getPopulationColor(pop, maxPop);
  }, [populationMap, maxPop, selectedGeoName, selectedCountry, hovered]);

  const getPolygonSideColor = useCallback((d: object) => {
    const feat = d as GeoFeature;
    const name = feat.properties.ADMIN || feat.properties.NAME;
    const isSelected = name === selectedGeoName || name === selectedCountry;
    if (isSelected) return 'rgba(0, 212, 255, 0.3)';
    return 'rgba(20, 50, 100, 0.15)';
  }, [selectedGeoName, selectedCountry]);

  const getPolygonAltitude = useCallback((d: object) => {
    const feat = d as GeoFeature;
    const name = feat.properties.ADMIN || feat.properties.NAME;
    const isSelected = name === selectedGeoName || name === selectedCountry;
    const isHovered = hovered && (hovered.properties.ADMIN === name || hovered.properties.NAME === name);

    if (isSelected) return 0.06;
    if (isHovered) return 0.03;
    return 0.01;
  }, [selectedGeoName, selectedCountry, hovered]);

  const getPolygonLabel = useCallback((d: object) => {
    const feat = d as GeoFeature;
    const name = feat.properties.ADMIN || feat.properties.NAME;
    const csvName = matchCountryName(name, populationMap);
    const pop = csvName ? populationMap.get(csvName) : null;
    const popStr = pop ? pop.toLocaleString() : 'N/A';

    return `
      <div style="
        background: rgba(4, 7, 20, 0.9);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(0, 212, 255, 0.3);
        border-radius: 12px;
        padding: 10px 14px;
        font-family: system-ui, sans-serif;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 212, 255, 0.1);
      ">
        <div style="font-size: 13px; font-weight: 700; color: #fff; margin-bottom: 4px;">${name}</div>
        <div style="font-size: 11px; color: rgba(0, 212, 255, 0.8);">
          Population: <span style="color: #fff; font-weight: 600;">${popStr}</span>
        </div>
      </div>
    `;
  }, [populationMap]);

  const handlePolygonClick = useCallback((d: object) => {
    const feat = d as GeoFeature;
    const name = feat.properties.ADMIN || feat.properties.NAME;
    onCountryClick(name);
  }, [onCountryClick]);

  const handlePolygonHover = useCallback((d: object | null) => {
    setHovered(d as GeoFeature | null);
    if (containerRef.current) {
      containerRef.current.style.cursor = d ? 'pointer' : 'default';
    }
  }, []);

  return (
    <div ref={containerRef} className="h-full w-full">
      <GlobeErrorBoundary
        fallback={
          <div className="h-full w-full flex items-center justify-center bg-gradient-to-b from-[#0a0e1a] to-[#060818]">
            <div className="text-center space-y-4">
              <div className="text-6xl">üåç</div>
              <p className="text-cyan-300/70 text-sm">3D Globe requires WebGL</p>
              <p className="text-white/40 text-xs">Select a country from the sidebar to explore</p>
            </div>
          </div>
        }
      >
        {isMounted && dimensions.width > 0 && (
          <Globe
            ref={globeRef}
            width={dimensions.width}
            height={dimensions.height}
            globeImageUrl="//unpkg.com/three-globe/example/img/earth-night.jpg"
            backgroundImageUrl="//unpkg.com/three-globe/example/img/night-sky.png"
            polygonsData={countries}
            polygonCapColor={getPolygonCapColor}
            polygonSideColor={getPolygonSideColor}
            polygonStrokeColor={() => 'rgba(100, 180, 255, 0.15)'}
            polygonAltitude={getPolygonAltitude}
            polygonLabel={getPolygonLabel}
            onPolygonClick={handlePolygonClick}
            onPolygonHover={handlePolygonHover}
            polygonsTransitionDuration={300}
            atmosphereColor="rgba(0, 150, 255, 0.4)"
            atmosphereAltitude={0.2}
            animateIn={true}
          />
        )}
      </GlobeErrorBoundary>
    </div>
  );
}
